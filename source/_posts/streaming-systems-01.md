---
layout:     post
title:      "「Notes」Streaming Systems（I）"
subtitle:   "Streaming 理论入门"
date:       2022-01-21
author:     "Ink Bai"
catalog:    true
header-style: "text"
tags:
    - Streaming Systems
---

## 基本术语解释：Streaming 到底是什么？
Streaming System：用来处理无限数据集的数据处理引擎。

可以从两个维度描述给定的数据集：

- 数据的有界和无界
- 表的表现形式和流的表现形式 ：注意流的表现形式是指数据一条接着一条，线性状态

#### 论 Streaming 被过分夸大的局限性
Streaming systems 常被用作 Lambda 架构中的补充，Lambda 架构就是同时包含了具有相同计算逻辑的 batch system 和 streaming system 的架构，streaming system 会提供低延迟、非精确的结果，并且会在之后通过 batch system 重新计算出精确的结果，替换 streaming system 的结果。Lambda 架构的缺点因此也很明显，你需要维护两套数据管线，并且最后还需要合并这两套数据管线的结果。

之后又出现了 Kappa 架构，即连接到一个可重放数据的系统如 Kafka，单条数据管道可同时处理批流数据的系统。

在我看来，设计良好的 streaming systems 应该完全可以具备 batch systems 的一切能力。而击败批处理系统只需要做到两件事情：

- 正确性：这一步可以确保跟批处理系统平起平坐。需要保存状态以容错恢复，保证数据的正确性
- 时间推理工具：这一步确保超越批处理系统。好的时间推理工具对于处理无界的、无序的、处理时间和事件时间存在偏差的数据是必不可少的。越来越多的现实数据集显示出这些特征。

#### 事件时间 VS 处理时间

- 事件时间：事件真正发生的时间
- 处理时间：事件到达系统的时间

真实世界中这两个时间不是完全相等的，会有如下图所示的偏差。从图中可以看到有两个表示偏差值的方式：

- 处理时间滞后
- 事件时间偏差

注意这两个值是完全相等的，实际上，在任何给定的时间点上，处理时间滞后和事件时间偏差是相同的；它们只是看待同一件事的两种方式而已。

![](/img/content/stsy_0101.png)

## 数据处理模式
讲人话就是有界数据和无界数据被处理的方式有哪些，下面进行讲解。

#### 有界数据
处理有界数据相对来说比较简单直接，可以使用传统批处理引擎如 MapReduce 或者一个设计优秀的流程里引擎处理数据。

![](/img/content/stsy_0102.png)

#### 无界数据：批处理
使用批处理引擎处理无界数据，常见的思路就是将无界数据分成多段有界数据集，再使用批处理引擎依次进行处理。

#### 无界数据：流处理
首先，真实世界中的无界数据具有如下特征：

- 数据高度无序
- 处理时间和事件时间存在偏差

处理具有以上特征的无界数据大体有下面几种方法：

**1. 时间无关的数据处理**
是一种处理数据时不关心时间的方式，所有的逻辑都是数据驱动的，无需考虑时间，比如判断一个 IP 来自哪个省市。
当然，对于这种处理，使用传统批处理也可以，把无界数据分割成多段有界数据集合即可。

**2. 近似算法**
近似算法是指输入无界数据源，输出近似准确的数据，比如 Top-N 算法，k-means 算法。
这里不展开讨论。

**3. 窗口**
窗口是指取一个数据源(无界的或有界的)，然后沿着时间边界将其分割成有限的块进行处理。
有以下三种窗口模式：

![](/img/content/stsy_0108.png)

- 固定窗口：固定窗口将时间分成具有固定大小的片段。
- 滑动窗口：是固定窗口的一般化。滑动窗口包含两个变量，窗口长度和滑动长度。 如果窗口长度等于滑动长度，就是一个固定窗口。 如果窗口长度大于滑动长度，窗口之间会重叠。 如果窗口长度小于滑动长度，只能拿到全部数据的一个子集，这种情况一般不常见。
- Session 窗口：是一种动态窗口。session 窗口不是提前定义的，而是在记录到来之后根据记录的状态实际定义的。最常用到 session 窗口的场景就是分析一段时间之内的用户行为。session 窗口是一种非对齐窗口，非对齐是指同一批数据存在不同的窗口，如不同的 key 对应的窗口是不一样的。

我们分别讨论处理时间和事件时间下的窗口。

**3.1 处理时间窗口**
处理时间窗口很简单，就是把收到的数据缓冲到一个窗口内，到了窗口的长度就转发出去。
它的优点就是足够简单，一些监控应用会使用基于处理时间的窗口，但是对于其他大部分应用，我们还是更加关心事件时间的，明显处理时间窗口不能满足要求。

**3.2 事件时间窗口**
事件时间窗口才能反映事件真实发生的时间段。
如下图分别是基于事件时间的固定窗口和 session 窗口，黑色剪头表示了进入的记录如何分配到下面对应的事件时间窗口内。

固定窗口
![](/img/content/stsy_0110.png)

session 窗口
![](/img/content/stsy_0111.png)

事件时间窗口很强大，但是由于窗口通常必须比窗口本身的实际长度（在处理时间上）活得更长，伴随而来的必然有一些缺点：

- 需要额外缓冲数据：由于窗口长度更长，缓冲的数据也更多，需要消耗更多的内存或者磁盘空间。
- 数据完整性：我们如何确定一个事件时间窗口何时能包含所有数据呢？答案是不能。后面我们会引入 watermark 机制来近似解决数据完整性。
