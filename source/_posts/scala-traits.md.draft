---
layout:     post
title:      "Scala Traits"
subtitle:   "Notes of Programming in Scala"
date:       2018-01-18
author:     "Ink Bai"
catalog:    true
# header-img: "http://ox2ru2icv.bkt.clouddn.com/image/jpg/post-bg-ddia.jpg"
tags:
    - Scala
---

> This article shows you how traits work and shows two of the most common ways they are useful: widening thin interfaces to rich ones, and defining stackable modifications.

## How traits work
Once a trait is defined, it can be mixed in to a class using either the extends or with keywords.

You can do anything in a trait definition that you can do in a class definition, and the syntax looks exactly the same, with only two exceptions.

- First, a trait cannot have any "class" parameters (i.e., parameters passed to the primary constructor of a class).
- The other difference between classes and traits is that whereas in classes, super calls are statically bound, in traits, they are dynamically bound.

## Traits as stackable modifications

```scala
trait Doubling extends IntQueue{
  abstract override def put(x: Int) = { super.put(2 * x) }
}
```

The second funny thing is that the trait has a super call on a method declared abstract. Such calls are illegal for normal classes because they will certainly fail at run time. For a trait, however, such a call can actually succeed. Since super calls in a trait are dynamically bound, the super call in trait Doubling will work so long as the trait is mixed in after another trait or class that gives a concrete definition to the method.

To tell the compiler you are doing this on purpose, you must mark such methods as abstract override. This combination of modifiers is only allowed for members of traits, not classes, and it means that the trait must be mixed into some class that has a concrete definition of the method in question.

Note that MyQueue defines no new code. It simply identifies a class and mixes in a trait. In this situation, you could supply "BasicIntQueue with Doubling" directly to new instead of defining a named class.

```scala
class MyQueue extends BasicIntQueue with Doubling

val queue = new MyQueue
```

```scala
val queue = new BasicIntQueue with Doubling
```

When you call a method on a class with mixins, the method in the trait furthest to the right is called first. If that method calls super, it invokes the method in the next trait to its left, and so on.

## To trait or not to trait?
If the behavior will not be reused, then make it a concrete class. It is not reusable behavior after all.

If it might be reused in multiple, unrelated classes, make it a trait. Only traits can be mixed into different parts of the class hierarchy.

If you want to inherit from it in Java code, use an abstract class.

If you plan to distribute it in compiled form, and you expect outside groups to write classes inheriting from it, you might lean towards using an abstract class.

If you still do not know, after considering the above, then start by making it as a trait.
