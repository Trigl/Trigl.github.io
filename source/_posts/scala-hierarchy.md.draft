---
layout:     post
title:      "Scala Hierarchy"
subtitle:   "Notes of Programming in Scala"
date:       2018-01-18
author:     "Ink Bai"
catalog:    true
# header-img: "img/jpg/post-bg-ddia.jpg"
tags:
    - Scala
---

## Scala's class hierachy
The root class Any has two subclasses: AnyVal and AnyRef.

AnyVal is the parent class of value classes in Scala. There are nine value classes built into Scala: Byte, Short, Char, Int, Long, Float, Double, Boolean, and Unit.

Unit, corresponds roughly to Java's void type.

The Int's methods min, max, until, to, and abs are all defined in a class scala.runtime.RichInt, and there is an implicit conversion from class Int to RichInt.

The other subclass of the root class Any is class AnyRef. This is the base class of all reference classes in Scala. As mentioned previously, on the Java platform AnyRef is in fact just an alias for class java.lang.Object.

---

## Scala's `==`
In some situations where efficiency is paramount, you would like to hash cons with some classes and compare their instances with reference equality.[3] For these cases, class AnyRef defines an additional eq method, which cannot be overridden and is implemented as reference equality (i.e., it behaves like == in Java for reference types). There's also the negation of eq, which is called ne.

## Bottom types
Class Null is the type of the null reference; it is a subclass of every reference class (i.e., every class that itself inherits from AnyRef). Null is not compatible with value types. You cannot, for example, assign a null value to an integer variable.

Type Nothing is at the very bottom of Scala's class hierarchy; it is a subtype of every other type.

Why does it make sense to have a type without values? One use of Nothing is that it signals abnormal termination.
For instance there's the error method in the Predef object of Scala's standard library, which is defined like this:

```scala
def error(message: String): Nothing =
  throw new RuntimeException(message)
```
